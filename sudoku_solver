#sudoku solver
# sample input: ,4,1,9,3,,,5,8,6,,9,,2,5,,4,,,2,8,7,1,,,3,6,,8,,,7,,,9,,3,,6,5,8,2,7,1,4,,,,6,9,3,8,2,5,,5,2,1,4,,,6,9,,,3,2,,8,4,7,1,,,,,6,,,8,2

#      Grid Relations                          Row Relations [grids]<-[rows]            Col Relations [grids]<-[cols]
# 0<-1,2,3,6; 1<-0,2,4,7; 2<-0,1,5,8                    0,1,2<-A,B,C                                0,3,6<-0,1,2
# 3<-0,4,5,6; 4<-1,3,5,7; 5<-2,3,4,8                    3,4,5<-D,E,F                                1,4,7<-3,4,5
# 6<-0,3,7,8; 7<-1,4,6,8; 8<-2,5,6,7                    6,7,8<-G,H,I                                2,5,8<-6,7,8

#grids=        [   0,       1,       2,       3,       4,       5,       6,       7,       8   ]
#rowscheck=    [[A,B,C], [A,B,C], [A,B,C], [D,E,F], [D,E,F], [D,E,F], [G,H,I], [G,H,I], [G,H,I]]
#colscheck=    [[0,1,2], [3,4,5], [6,7,8], [0,1,2], [3,4,5], [6,7,8], [0,1,2], [3,4,5], [6,7,8]]
#assume we are trying to fill in a 9 into grid 2.  This involves two row checks
#Already know that there is no 9 in grid 2.  Check if row A has a 9.  It does so there cannot be a 9 in row A.0th
#Check if row B has a 9.  It does so there cannot be a 9 in row B.  So the 9 must be in row C.
#Check how many 0's are in row C of the grid.  How to do that?  grid 2 is far right;
# so list[9-i]->list[9-i+2] gets the corresponding row elements in grid 2.  But this might lead to bugs.  does that work elsewhere?
# grid 1 is middle grid, so it wants rowX[3],rowX[4],rowX[5]


#new approach: use the old puzzleList structure, and perform math on it.  e.g. index % 9 will give you the column you want
#how to get the row you want?  switch statement or maybe dictionary
# could you use a dictionary saying index i is row x, col y, grid z?
# that sounds like a smarter solution.  consider making a new file and branch for this.
# hybrid approach: list storing indices e.b. rowB=[9,10,11,12,13,14,15,16,17] would make fillInNinth more clear

#grid numbers are straightforward:
# 0   1   2
# 3   4   5          grids that correspond with each other:
# 6   7   8

#    0 1 2   3 4 5   6 7 8      <-- col numbers

#0  |_|4|1| |9|3|_| |_|5|8|                 |00|01|02| |03|04|05| |06|07|08|
#1  |6|_|9| |_|2|5| |_|4|_|                 |09|10|11| |12|13|14| |15|16|17|
#2  |_|2|8| |7|1|_| |_|3|6|                 |18|19|20| |21|22|23| |24|25|26|
#
#3  |_|8|_| |_|7|_| |_|9|_|                 |27|28|29| |30|31|32| |33|34|35|
#4  |3|_|6| |5|8|2| |7|1|4|                 |36|37|38| |39|40|41| |42|43|44|
#5  |_|_|_| |6|9|3| |8|2|5|                 |45|46|47| |48|49|50| |51|52|53|
#
#6  |_|5|2| |1|4|_| |_|6|9|                 |54|55|56| |57|58|59| |60|61|62|
#7  |_|_|3| |2|_|8| |4|7|1|                 |63|64|65| |66|67|68| |69|70|71|
#8  |_|_|_| |_|6|_| |_|8|2|                 |72|73|74| |75|76|77| |78|79|80|
#
#^row numbers


# TODO LIST
#1.  need an update method to call after each # is filled in so that minimum number of sets are constructed
#        Must be called after autoComplete
#        update method will update all three affected by most recent change. update also needs to update grids.
#2.  should I keep puzzleList as a global?  can't really see a reason to yet
#3   define globals A=0,B=1,C=2, etc. so you can use them for row referencing

# 0: 0,1,2,9,10,11,18,19,20

puzzleList = []

reverseGridDictionary = {0: [0, 1, 2, 9, 10, 11, 18, 19, 20],
                         1: [3, 4, 5, 12, 13, 14, 21, 22, 23],
                         2: [6, 7, 8, 15, 16, 17, 24, 25, 26],
                         3: [27, 28, 29, 36, 37, 38, 45, 46, 47],
                         4: [30, 31, 32, 39, 40, 41, 48, 49, 50],
                         5: [33, 34, 35, 42, 43, 44, 51, 52, 53],
                         6: [54, 55, 56, 63, 64, 65, 72, 73, 74],
                         7: [57, 58, 59, 66, 67, 68, 75, 76, 77],
                         8: [60, 61, 62, 69, 70, 71, 78, 79, 80]}
gridDictionary = {0: 0, 1: 0, 2: 0, 9: 0, 10: 0, 11: 0, 18: 0, 19: 0, 20: 0, 3: 1, 4: 1, 5: 1,
    12: 1, 13: 1, 14: 1, 21: 1, 22: 1, 23: 1, 6: 2, 7: 2, 8: 2, 15: 2, 16: 2, 17: 2, 24: 2, 25: 2,
    26: 2, 27: 3, 28: 3, 29: 3, 36: 3, 37: 3, 38: 3, 45: 3, 46: 3, 47: 3, 30: 4, 31: 4, 32: 4, 39: 4,
    40: 4, 41: 4, 48: 4, 49: 4, 50: 4, 33: 5, 34: 5, 35: 5, 42: 5, 43: 5, 44: 5, 51: 5, 52: 5, 53: 5,
    54: 6, 55: 6, 56: 6, 63: 6, 64: 6, 65: 6, 72: 6, 73: 6, 74: 6, 57: 7, 58: 7, 59: 7, 66: 7, 67: 7,
    68: 7, 75: 7, 76: 7, 77: 7, 60: 8, 61: 8, 62: 8, 69: 8, 70: 8, 71: 8, 78: 8, 79: 8, 80: 8}


def crossSolve(puzzleList):
    for i in range(1, 10):  # look for numbers 1-9
        for j in range(0, 9):  # look at all grids
            workingList = reverseGridDictionary[j]
            zeroSpots = []
            for k in range(0, 9):
                if puzzleList[workingList[k]] == 0:
                    zeroSpots.append(workingList[k])  # grab all the zeros, we need them for the next part
            for k in range(0, 9):
                if puzzleList[workingList[k]] == i:
                    break
            else:  # i is not in grid, proceed to cross-checking each 0spot with rows and cols around it
                if len(zeroSpots) == 0:
                    break
                for m in range(0, len(zeroSpots)):
                    focus = zeroSpots[m]  # in here, zeroSpots[m] will refer to an index in puzzleList that has a value of 0 right now
                    for n in range(((focus / 9) * 9), (((focus / 9) * 9) + 9)):  # index/9 will return row #, and multiplying that result by 9
                                                                                # gives starting index of row #
                        if(puzzleList[n]) == i:  # something in this row matches the value we are hoping to fill in for the 0
                            zeroSpots[m] = -1  # this acts as a flag marking it for deletion.  Deleting zero spots because if we
                                               # are left with one zerospot, then it will be set to i, since above conditions have
                                               # been met already
                    for n in range(focus % 9, (focus % 9) + 73, 9):  # used to get other indices of that column
                        if(puzzleList[n]) == i:
                            zeroSpots[m] = -1
                for m in range(0, zeroSpots.count(-1)):  # cleaning up the list
                    zeroSpots.remove(-1)
                if len(zeroSpots) == 1:
                    puzzleList[zeroSpots[0]] == i


def puzzleMaker(puzzle):
    puzzleList = puzzle.split(',')  # couldn't see how to pass as a list, so I made it a string and change it here
    for i in range(0, 81):
        if (puzzleList[i]) == '':
            puzzleList[i] = '0'
    for i in range(0, 81):            # these two loops aren't really necessary but now I can work with 0-9 instead of strings and blanks,
                                      # and that is more intuitive.
        puzzleList[i] = int(puzzleList[i])
    return puzzleList


def main():
    puzzleList = puzzleMaker(",4,1,9,3,,,5,8,6,,9,,2,5,,4,,,2,8,7,1,,,3,6,,8,,,7,,,9,,3,,6,5,8,2,7,1,4,,,,6,9,3,8,2,5,,5,2,1,4,,,6,9,,,3,2,,8,4,7,1,,,,,6,,,8,2")
    crossSolve(puzzleList)
    print(puzzleList)

main()
