#sudoku solver
# sample input: ,4,1,9,3,,,5,8,6,,9,,2,5,,4,,,2,8,7,1,,,3,6,,8,,,7,,,9,,3,,6,5,8,2,7,1,4,,,,6,9,3,8,2,5,,5,2,1,4,,,6,9,,,3,2,,8,4,7,1,,,,,6,,,8,2


#grid numbers are straightforward:
# 0   1   2
# 3   4   5
# 6   7   8


#    0 1 2   3 4 5   6 7 8  <-- col numbers
#                                              Grid 0     Grid 1     Grid 2
#0  |_|4|1| |9|3|_| |_|5|8|                  |00|01|02| |03|04|05| |06|07|08|
#1  |6|_|9| |_|2|5| |_|4|_|                  |09|10|11| |12|13|14| |15|16|17|
#2  |_|2|8| |7|1|_| |_|3|6|                  |18|19|20| |21|22|23| |24|25|26|
#                                              Grid 3     Grid 4     Grid 5
#3  |_|8|_| |_|7|_| |_|9|_|                  |27|28|29| |30|31|32| |33|34|35|
#4  |3|_|6| |5|8|2| |7|1|4|                  |36|37|38| |39|40|41| |42|43|44|
#5  |_|_|_| |6|9|3| |8|2|5|                  |45|46|47| |48|49|50| |51|52|53|
#                                              Grid 6     Grid 7     Grid 8
#6  |_|5|2| |1|4|_| |_|6|9|                  |54|55|56| |57|58|59| |60|61|62|
#7  |_|_|3| |2|_|8| |4|7|1|                  |63|64|65| |66|67|68| |69|70|71|
#8  |_|_|_| |_|6|_| |_|8|2|                  |72|73|74| |75|76|77| |78|79|80|
#
#^row numbers

# puzzleList will be the Sudoku puzzle; the dictionaries map indices of puzzleList into grids 0-8.
puzzleList = []
reverseGridDictionary = {0: [0, 1, 2, 9, 10, 11, 18, 19, 20],
                         1: [3, 4, 5, 12, 13, 14, 21, 22, 23],
                         2: [6, 7, 8, 15, 16, 17, 24, 25, 26],
                         3: [27, 28, 29, 36, 37, 38, 45, 46, 47],
                         4: [30, 31, 32, 39, 40, 41, 48, 49, 50],
                         5: [33, 34, 35, 42, 43, 44, 51, 52, 53],
                         6: [54, 55, 56, 63, 64, 65, 72, 73, 74],
                         7: [57, 58, 59, 66, 67, 68, 75, 76, 77],
                         8: [60, 61, 62, 69, 70, 71, 78, 79, 80]}
gridDictionary = {0: 0, 1: 0, 2: 0, 9: 0, 10: 0, 11: 0, 18: 0, 19: 0, 20: 0, 3: 1, 4: 1,
     5: 1, 12: 1, 13: 1, 14: 1, 21: 1, 22: 1, 23: 1, 6: 2, 7: 2, 8: 2, 15: 2, 16: 2, 17: 2, 24: 2,
    25: 2, 26: 2, 27: 3, 28: 3, 29: 3, 36: 3, 37: 3, 38: 3, 45: 3, 46: 3, 47: 3, 30: 4, 31: 4, 32: 4,
    39: 4, 40: 4, 41: 4, 48: 4, 49: 4, 50: 4, 33: 5, 34: 5, 35: 5, 42: 5, 43: 5, 44: 5, 51: 5, 52: 5,
    53: 5, 54: 6, 55: 6, 56: 6, 63: 6, 64: 6, 65: 6, 72: 6, 73: 6, 74: 6, 57: 7, 58: 7, 59: 7, 66: 7,
    67: 7, 68: 7, 75: 7, 76: 7, 77: 7, 60: 8, 61: 8, 62: 8, 69: 8, 70: 8, 71: 8, 78: 8, 79: 8, 80: 8}


def crossSolve(puzzleList):
    flag = 0
    for i in range(1, 10):  # look for numbers 1-9
        for j in range(0, 9):  # look at all grids
            workingList = reverseGridDictionary[j]
            zeroSpots = []
            for k in range(0, 9):
                if puzzleList[workingList[k]] == 0:
                    zeroSpots.append(workingList[k])  # grab all the zeros, we need them for the next part

            if len(zeroSpots) == 1:
                gridFillInNinth(puzzleList, j)  # this is built into crossSolve but I made a shortcut / shorter function if the grid already has 8/9
                flag = 1
                break  # if you get weird behavior this may be the culprit.  I am guessing on this.

            for k in range(0, 9):
                if puzzleList[workingList[k]] == i:
                    break
            else:  # i is not in grid, proceed to cross-checking each 0spot with rows and cols around it
                if len(zeroSpots) == 0:
                    break
                for m in range(0, len(zeroSpots)):
                    index = zeroSpots[m]  # in here, zeroSpots[m] will refer to an index in puzzleList that has a value of 0 right now
                    for n in range(((index / 9) * 9), (((index / 9) * 9) + 9)):  # index/9 will return row #, and multiplying that result by 9
                                                                                # gives starting index of row #
                        if(puzzleList[n]) == i:  # something in this row matches the value we are hoping to fill in for the 0
                            zeroSpots[m] = -1  # this acts as a flag marking it for deletion.  Deleting zero spots because if we
                                               # are left with one zerospot, then it will be set to i, since above conditions have
                                               # been met already

                    for n in range(index % 9, (index % 9) + 73, 9):  # used to get other indices of that column
                        if(puzzleList[n]) == i:
                            zeroSpots[m] = -1

                for m in range(0, zeroSpots.count(-1)):  # cleaning up the list
                    zeroSpots.remove(-1)
                if len(zeroSpots) == 1:
                    puzzleList[zeroSpots[0]] = i
                    flag = 1
    return flag


def puzzleMaker(puzzle):
    puzzleList = puzzle.split(',')  # couldn't see how to pass as a list, so I made it a string and change it here
    for i in range(0, 81):
        if (puzzleList[i]) == '':
            puzzleList[i] = '0'
    for i in range(0, 81):            # these two loops aren't really necessary but now I can work with 0-9 instead of strings and blanks,
                                      # and that is more intuitive.
        puzzleList[i] = int(puzzleList[i])
    return puzzleList


def gridFillInNinth(puzzleList, gridNumber):  # maybe call this if you know the grid has one zero?
    for i in range(1, 10):
        for j in range(0, 9):  # last step: find the single 0 you know exists, and replace it with the number you are on
            if puzzleList[reverseGridDictionary[gridNumber][j]] == i:
                break  # go back up to i, increment it, and start looking for the next number in the grid
        else:
            for k in range(0, 9):
                if(puzzleList[reverseGridDictionary[gridNumber][k]] == 0):
                    puzzleList[reverseGridDictionary[gridNumber][k]] = i
                    return puzzleList


def rowFillInNinth(puzzleList, indexFromRow):
    for i in range(1, 10):
        for j in range((indexFromRow / 9) * 9, ((indexFromRow / 9) * 9) + 9):
            if puzzleList[j] == i:
                break
        else:
            for k in range((indexFromRow / 9) * 9, ((indexFromRow / 9) * 9) + 9):
                if puzzleList[k] == 0:
                    puzzleList[k] = i
                    return puzzleList


def colFillInNinth(puzzleList, indexFromCol):
    for i in range(1, 10):
        for j in range(indexFromCol % 9, (indexFromCol % 9) + 73, 9):
            if puzzleList[j] == i:
                break
        else:
            for k in range(indexFromCol % 9, (indexFromCol % 9) + 73, 9):
                if puzzleList[k] == 0:
                    puzzleList[k] = i
                    return puzzleList


def findPossibleValues(puzzleList, index):  # used when there are multiple solutions to a sudoku
    possibleValuesFromRow = [1, 2, 3, 4, 5, 6, 7, 8, 9]  # makes more sense to assume all are possible and eliminate as you go along
    possibleValuesFromCol = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    for i in range(1, 10):
        for j in range(((index / 9) * 9), (((index / 9) * 9) + 9)):  # check rows
            #if (puzzleList[j] == 0 and j != index):  # there is another zero in this row, and row checking for values becomes useless
                #possibleValuesFromRow = [1, 2, 3, 4, 5, 6, 7, 8, 9]  # need to reset since info obtained is now determined to be useless
             #   break
            if puzzleList[j] == i:
                    if(len(possibleValuesFromRow) == 0):
                        break
                    else:
                        if i in possibleValuesFromRow:
                            possibleValuesFromRow.remove(i)
        for j in range(index % 9, (index % 9) + 73, 9):
            #if (puzzleList[j] == 0 and j != index):
                #possibleValuesFromCol = [1, 2, 3, 4, 5, 6, 7, 8, 9]
            #    break
            if puzzleList[j] == i:
                if(len(possibleValuesFromCol) == 0):
                    break
                else:
                        if i in possibleValuesFromCol:
                            possibleValuesFromCol.remove(i)
    return list(set(possibleValuesFromRow).intersection(set(possibleValuesFromCol)))


def resetZeros(puzzleList, listOfZeros):
    for i in range(0, len(listOfZeros)):
        puzzleList[listOfZeros[i]] = 0



def isPuzzleSolved(puzzleList):
    listOfZeros = []
    for i in range(0,81):
        if puzzleList[i] == 0:
            listOfZeros.append(i)
    return listOfZeros

def drawPuzzle(puzzleList):
    for i in range(0, 81, 9):
        s = ("|" + str(puzzleList[i]) + "|" + str(puzzleList[i + 1]) + "|" + str(puzzleList[i + 2]) +
             "| |" + str(puzzleList[i + 3]) + "|" + str(puzzleList[i + 4]) + "|" + str(puzzleList[i + 5]) +
             "| |" + str(puzzleList[i + 6]) + "|" + str(puzzleList[i + 7]) + "|" + str(puzzleList[i + 8]) + "|")
        print(s)


def main():
    puzzleList = puzzleMaker(",4,1,9,3,,,5,8,6,,9,,2,5,,4,,,2,8,7,1,,,3,6,,8,,,7,,,9,,3,,6,5,8,2,7,1,4,,,,6,9,3,8,2,5,,5,2,1,4,,,6,9,,,3,2,,8,4,7,1,,,,,6,,,8,2")
    i = 1
    while i is 1:
        i = crossSolve(puzzleList)
        # crossSolve returns a flag value indicating whether or not it made a change.  While loop stops if crossSolve no longer does anything
    listOfZeros = isPuzzleSolved(puzzleList)
    if (len(listOfZeros) == 0):
        drawPuzzle(puzzleList)
    else:
        possibleValues = findPossibleValues(puzzleList, listOfZeros[0]) #starting with first 0 found should be enough for my purposes here
        if (len(possibleValues)) == 0:
            print("unexpected result: looking for multiple solutions but none found!")
        else:
            for i in range(0, len(possibleValues)):
                puzzleList[listOfZeros[0]] = possibleValues[i]
                j = 1
                while j is 1:
                    j = crossSolve(puzzleList)
                print("solution number: ", i+1)
                drawPuzzle(puzzleList)
                resetZeros(puzzleList, listOfZeros)


main()
